-------------------------------------------------
    Responsibilities of Parsing
-------------------------------------------------

- parses one commandline into tokens
- if the first token is 'exit' exits minishell
        //TODO is there any other case where the program does not proceed?
- organises those tokens into a datastructure
        //TODO what is that datastucture?
        //does it make to have a struct like this:
        //  struct command
        //  {
        //      name_of_command
        //      flag
        //      infile
        //      outfile
        //  }
        //how would we then handle the expansion (?) of 

-------------------------------------------------
    Parsing Cases
-------------------------------------------------

Basic -------------------------------------------

ls					-	
ls -a				-"ls" "-a" are two seperate tokens?
ls -l -a			-two flags seperate (same outcome as: ls -la)
ls -la      		-two flags in one (same outcome as: ls -l -a)
/bin/bash			-just a path
cat infile			-using a file

Exit --------------------------------------------

Error codes are between 0 and 255

minishell: exit a
exit
bash: exit: a: numeric argument required
zsh:

minishell: exit 3
exit
zsh: echo $?
3
zsh: 

minishell: exit 356
exit
zsh: echo $?
100
zsh:
(bash uses 8bits to store the exit code, so it will wrap higher numbers to fit 0-255)

minishell: exit 3 a
exit
bash: exit: too many arguments
minishell:

minishell: exit_______________
exit
zsh:

minishell: exit \t\t\t\t\t\t\t\t
exit
zsh:

minishell: _exit
exit
zsh: 

minishell: a exit
a: command not found
minishell: 

Built_In Commands -------------------------------

echo hello			-Why is echo a built in command?
echo -n hello		-echo only needs -n flags
cd
pwd
export

Pipes -------------------------------------------

ls | wc								-basic pipe
< infile cat | wc > outfile			-pipex imitation
< infile cat | wc >> outfile		->> appends the outfile instead of overwrite
< infile notcat | ls > outfile		-pipex bad command
< infile sleep 10 | ls > outfile	-pipex sleep test

Redirection -------------------------------------

cat < infile	-cat is reading from infile
< infile cat	-same
cat infile		-same

Combination of single and double quotes ---------

grep "Hello World" file.txt         -looks for Hello World
grep 'Hello World' file.txt         -looks for Hello World
grep '"Hello World"' file.txt       -looks for "Hello World" WITH the double quotes
search_term="World"; grep "Hello '$search_term'" file.txt     -looks for Hello 'World'
search_term="World"; grep "Hello $search_term" file.txt       -looks for Hello World
grep 'The cost is $100' file.txt		-$ is NOT interpretted in single quotes
grep "The cost is $100" file.txt		-$ IS interpretted in double quotes
grep "It's a beautiful day" file.txt	-single quote is just char


Non-Linear --------------------------------------

ls $(echo /usr | cat)		-the content of () are executed first, then the "ls"
ls "$(echo /usr | cat)"		-..
ls `echo /usr`              - same thing but different syntax


Heredoc -----------------------------------------

<< cat | wc		-Basic heredoc
grep "Hello World" << end   -heredoc in the middle (as any file)

Variables ---------------------------------------

var="World"
VAR="Hello World"
VAR=Hello
VAR="Hell $(var)"

Exit status -------------------------------------

echo $?     -exit status of the last commandline
            // $? is the only one of the special shell variables that we need to handle

Maybe -------------------------------------------

cat &		-suspends the command. maybe don't have to do this?
cat<<<Makefile















































